<html><head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
  <link rel="stylesheet" href="bootstrap.min.css">
  <link rel="stylesheet" href="main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap">
  <script src="https://kit.fontawesome.com/1e36e2dfe7.js" crossorigin="anonymous"></script>
  <script src="jquery.min.js"></script>
  <script src="bootstrap.min.js"></script>
  <script src="highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="fuse.min.js"></script>
  <script src="dox2web.js"></script>
  <title>Visionary Render Programming Guide: Writing Surface Shaders</title>
</head>
<body><a class="main-logo" href="https://www.virtalis.com" target="_blank" rel="noopener noreferrer"></a>
<nav class="navbar navbar-inverse navbar-fixed-top navbar-lower" role="navigation">
  <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-nav-contents" aria-expanded="false">
    <span class="sr-only">Toggle navigation</span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <div class="collapse navbar-collapse" id="bs-nav-contents"><ul class="nav navbar-nav" id="main-menu">
    <li><a href="index.html">Overview</a></li>
    <li><a href="pages.html">Contents</a></li>
    <li><a href="modules.html">API</a></li>
  </ul>
</nav>
<div class="shove"><div class="container-fluid"><div class="col-sm-10 col-sm-push-2 main"><nav aria-label = "breadcrumb"><ol class="breadcrumb forward-slash"><li class = "breadcrumb-item "><a href = "index.html">Overview</a></li><li class = "breadcrumb-item"><a href="advanced.html">Advanced Topics</a></li><li class = "breadcrumb-item active">Writing Surface Shaders</li></ol></nav><div class="page-toc"><ol><li><strong>Contents</strong></li><li><a href="#">Writing Surface Shaders</a></li><ol><li><a href="#jHX1NsnwJduC">Creating the assemblies</a></li><ol><li><a href="#MEmS7ljKDTgL">1. Click and drag a surface shader definition on to an object in the scene.</a></li><li><a href="#xCFqxkhOcWMa">2. Right-Click on a Material and select "Create -> Surface Shader Instance".</a></li></ol><li><a href="#8Z0FTf52ozI8">Writing the Shader</a></li><ol><li><a href="#Iv4k59LNw8Vn">surface( )</a></li><ol><li><a href="#2OsviSmJkkZk">SurfaceInput</a></li><li><a href="#WolYT45jc61M">SurfaceOutput</a></li></ol><li><a href="#GUupTQBY74Rm">litSurface()</a></li><ol><li><a href="#LeagbMyCQHeS">LitFragment</a></li><li><a href="#KYwMZqWZlsEm">evalLighting()</a></li><ol><li><a href="#Ls11sqiHWxgo">Fragment structure</a></li></ol><li><a href="#rBLlRBInd37d">vertex( )</a></li><li><a href="#g5JFpjc2U5q4">Uniforms</a></li><li><a href="#TNOQS2qqDb8M">Input Parameters</a></li></ol></div><h1>Writing Surface Shaders</h1><p>A guide to writing shaders that can be applied to materials in your scene.</p><p>Surface Shaders allow custom shading to be applied to visuals within the scene.</p><p>When a surface shader is applied to a material, all visuals using that material will run the custom shader when rendering.</p><p><h2 class="anchor" id="jHX1NsnwJduC">Creating the assemblies</h2></p><p>There are two Surface Shader assemblies that can be created under a Library assembly in the Developer tree view:</p><p><ul><li><p><strong>Surface Shader Definition</strong>: This is the script's assembly which should be created first. Double-click to open in the Script Editor.</p></li><li><p><strong>Surface Shader Instance</strong>: This assembly contains one property, which is a reference to the Surface Shader Definition of which it is an instance of. This is what gets added to a material to trigger the surface shader defined in the definition to be used in-place of the material.</p></li></ul></p><p>A shader definition is the first thing which should be created, and provides the base object which a surface shader instance will reference. After creating a defintion, an instance can be created in a couple of ways:</p><p><h4 class="anchor" id="MEmS7ljKDTgL">1. Click and drag a surface shader definition on to an object in the scene.</h4></p><p><img src="surface_shader_click_drag_apply.png"></img></p><p>This will create a surface shader instance as a child of that object's assigned material, with its Surface Shader property already referencing the definition.</p><p><img src="surface_shader_instance_applied.png"></img></p><p><h4 class="anchor" id="xCFqxkhOcWMa">2. Right-Click on a Material and select "Create -> Surface Shader Instance".</h4></p><p><img src="surface_shader_create.png"></img></p><p>Then, ensure the "Surface Shader" property references the desired definition.</p><p><h2 class="anchor" id="8Z0FTf52ozI8">Writing the Shader</h2></p><p>After creating and opening a surface shader definition, use the following guide to get started with creating a custom surface shader. Note: Surface Shaders are written in OpenGL Shading Language (GLSL) and so prior knowledge is desirable.</p><p><h3 class="anchor" id="Iv4k59LNw8Vn">surface( )</h3></p><p>The surface function gives the ability to modify the properties of a fragment before any lighting calculations are performed. It must take the following form:</p><p><div id="frag_Q84RxXmvNf8K"><ul class="nav nav-pills"><li class="active"><a href="#GLSLQ84RxXmvNf8K">GLSL</a></li></ul><div class="tab-content"><div id="GLSLQ84RxXmvNf8K" class="tab-pane active"><pre><code class="glsl">void surface(SurfaceInput i, inout SurfaceOutput o)
{
  o.albedo = vec3(1.0, 0.0, 0.0);
}
</code></pre></div>
</div></div>
That simple function will set the albedo of the fragment to red. The SurfaceInput parameter contains data about the current fragment being processed which may be useful in creating a surface shader. The SurfaceOutput parameter is where the desired surface details should be written out to.</p><p><h4 class="anchor" id="2OsviSmJkkZk">SurfaceInput</h4></p><p>This structure contains data about the current fragment which may come in handy for creating a desired shader. Following is a list of all the possible members of this structure:</p><p><dl><dd><div class="table-responsive"><table class="table table-striped table-bordered"><thead><tr><th><p><strong>Name</strong></p></th><th><p><strong>Type</strong></p></th><th><p><strong>Description</strong></p></th></tr></thead><tbody><tr><td><p>position</p></td><td><p>vec3</p></td><td><p>The eye-space position.</p></td></tr><tr><td><p>normal</p></td><td><p>vec3</p></td><td><p>The eye-space normal.</p></td></tr><tr><td><p>tangent </p></td><td><p>vec3 </p></td><td><p>The eye-space tangent. </p></td></tr><tr><td><p>bitangent </p></td><td><p>vec3 </p></td><td><p>The eye-space bitangent. </p></td></tr><tr><td><p>uv0 </p></td><td><p>vec2 </p></td><td><p>The UV value of TexCoord0. </p></td></tr><tr><td><p>uv1 </p></td><td><p>vec2 </p></td><td><p>The UV value of TexCoord1. </p></td></tr><tr><td><p>uv2 </p></td><td><p>vec2 </p></td><td><p>The UV value of TexCoord2. </p></td></tr><tr><td><p>uv3 </p></td><td><p>vec2 </p></td><td><p>The UV value of TexCoord3. </p></td></tr><tr><td><p>alpha </p></td><td><p>float </p></td><td><p>Alpha value, describes opacity. </p></td></tr><tr><td><p>reflection </p></td><td><p>vec3 </p></td><td><p>Eye-space reflection vector for the fragment. <strong>[Available in surface() only]</strong></p></td></tr><tr><td><p>direction </p></td><td><p>vec3 </p></td><td><p>View direction for the fragment. <strong>[Available in surface() only]</strong></p></td></tr><tr><td><p>position_world </p></td><td><p>vec3 </p></td><td><p>World-Space position of the vertex. <strong>[Available in vertex() only]</strong></p></td></tr><tr><td><p>position_model </p></td><td><p>vec3 </p></td><td><p>Model-Space position of the vertex. <strong>[Available in surface() only]</strong></p></td></tr></tbody></table></div></dd></dl>
By default, nothing needs to be done to gain access to position and normal. However, to access any of the other members they must be declared within a SurfaceInput struct definition as below:</p><p><div id="frag_UfKNMI5uEiiz"><ul class="nav nav-pills"><li class="active"><a href="#GLSLUfKNMI5uEiiz">GLSL</a></li></ul><div class="tab-content"><div id="GLSLUfKNMI5uEiiz" class="tab-pane active"><pre><code class="glsl">struct SurfaceInput 
{
  vec3 tangent;
  vec2 uv0;
  float alpha;
}
</code></pre></div>
</div></div>
Putting the above in our file (before any of the data members are used) will give us access to tangent, uv0, and alpha from the SurfaceInput object passed into vertex() and/or surface(). It does not matter that position and normal are missing from this definition, these will be added behind the scenes and so will still be available in the shader.</p><p><h4 class="anchor" id="WolYT45jc61M">SurfaceOutput</h4></p><p>This structure is used as the output of the surface( ) function. Following is a list of all the data members available for writing out to.</p><p><dl><dd><div class="table-responsive"><table class="table table-striped table-bordered"><thead><tr><th><p><strong>Name</strong></p></th><th><p>Type </p></th><th><p>Description  </p></th></tr></thead><tbody><tr><td><p>position </p></td><td><p>vec3 </p></td><td><p>Eye-space position passed on to the remaining shader pipeline to undergo lighting. </p></td></tr><tr><td><p>normal </p></td><td><p>vec3 </p></td><td><p>Eye-space normal passed on to the remaining shader pipeline to undergo lighting. </p></td></tr><tr><td><p>albedo </p></td><td><p>vec3 </p></td><td><p>Surface albedo used for lighting calculations. </p></td></tr><tr><td><p>emissive </p></td><td><p>vec3 </p></td><td><p>Emissive output from the surface. </p></td></tr><tr><td><p>smoothness </p></td><td><p>float </p></td><td><p>Adjusts how smooth the material's surface appears, 0 being very rough and 1 being perfectly smooth. </p></td></tr><tr><td><p>reflectivity </p></td><td><p>float </p></td><td><p>A value from 0 to 1 representing the amount of light that is reflected. </p></td></tr><tr><td><p>metalness </p></td><td><p>float </p></td><td><p>A value from 0 to 1 representing how metallic the surface is. </p></td></tr><tr><td><p>ambient </p></td><td><p>float </p></td><td><p>How much to scale ambient lighting for this surface. </p></td></tr><tr><td><p>alpha </p></td><td><p>float </p></td><td><p>Adjusts the translucency of the surface. </p></td></tr><tr><td><p>IBL </p></td><td><p>float </p></td><td><p>Set to 0.0 or 1.0 to either disable/enable Image-Based Lighting for this surface fragment. </p></td></tr></tbody></table></div></dd></dl>
Unlike with SurfaceInput, we do not need to define this structure within our file; all of the data members are available for reading/writing within the surface( ) function.</p><p><h3 class="anchor" id="GUupTQBY74Rm">litSurface()</h3></p><p>When the aforementioned surface() function is declared, the contents of the output structure SurfaceOutput goes on to get passed through the renderers lighting path. This may not be desirable if custom lighting has already been applied (such as using evalLighting() described later), this is where litSurface() comes in. It is used in place of the surface() function and uses the new structure LitFragment for its output:</p><p><div id="frag_X2qNssLVLOIu"><ul class="nav nav-pills"><li class="active"><a href="#GLSLX2qNssLVLOIu">GLSL</a></li></ul><div class="tab-content"><div id="GLSLX2qNssLVLOIu" class="tab-pane active"><pre><code class="glsl">void litSurface(SurfaceInput i, inout LitFragment o)
{
  o.colour = vec4(1.0, 0.0, 0.0, 1.0);
}
</code></pre></div>
</div></div><h4 class="anchor" id="LeagbMyCQHeS">LitFragment</h4></p><p>As previously mentioned this structure is used to store the output of the litSurface() function. Unlike SurfaceOutput it only has two members:</p><p><dl><dd><div class="table-responsive"><table class="table table-striped table-bordered"><thead><tr><th><p><strong>Name</strong></p></th><th><p>Type </p></th><th><p>Description  </p></th></tr></thead><tbody><tr><td><p>colour </p></td><td><p>vec4 </p></td><td><p>The final desired colour of this surface, where the alpha channel controls the translucency. </p></td></tr><tr><td><p>position </p></td><td><p>vec3 </p></td><td><p>Eye-space position passed on to the remaining renderer shading pipeline. </p></td></tr></tbody></table></div></dd></dl><h4 class="anchor" id="KYwMZqWZlsEm">evalLighting()</h4></p><p><div id="frag_vkNpQLDRUdRD"><ul class="nav nav-pills"><li class="active"><a href="#GLSLvkNpQLDRUdRD">GLSL</a></li></ul><div class="tab-content"><div id="GLSLvkNpQLDRUdRD" class="tab-pane active"><pre><code class="glsl">vec4 evalLighting(in Fragment input);
</code></pre></div>
</div></div>
This function can be called from within surface() or litSurface(). Callers pass in a filled-in Fragment structure and it returns the resulting lit colour in a vec4. Following is an example usage:</p><p><div id="frag_MblfJM5789Hq"><ul class="nav nav-pills"><li class="active"><a href="#GLSLMblfJM5789Hq">GLSL</a></li></ul><div class="tab-content"><div id="GLSLMblfJM5789Hq" class="tab-pane active"><pre><code class="glsl">void litSurface(SurfaceInput i, inout LitFragment o)
{
  Fragment frag;
  frag.albedo = vec3(0.0, 1.0, 0.0);
  frag.normal = i.normal;
  frag.position = i.position;
  // ...
  vec4 lightingResult = evalLighting(frag);
  o.colour = lightingResult;
}
</code></pre></div>
</div></div><h5 class="anchor" id="Ls11sqiHWxgo">Fragment structure</h5></p><p>This structure is used to pass into a call to evalLighting(). All members should be assigned a value to ensure no garbage is placed in unassigned members. Following is a table of all members available:</p><p><dl><dd><div class="table-responsive"><table class="table table-striped table-bordered"><thead><tr><th><p><strong>Name</strong></p></th><th><p>Type </p></th><th><p>Description  </p></th></tr></thead><tbody><tr><td><p>position </p></td><td><p>vec3 </p></td><td><p>Eye-space position passed on to the remaining shader pipeline to undergo lighting. </p></td></tr><tr><td><p>normal </p></td><td><p>vec3 </p></td><td><p>Eye-space normal passed on to the remaining shader pipeline to undergo lighting. </p></td></tr><tr><td><p>albedo </p></td><td><p>vec3 </p></td><td><p>Surface albedo used for lighting calculations. </p></td></tr><tr><td><p>emissive </p></td><td><p>vec3 </p></td><td><p>Emissive output from the surface. </p></td></tr><tr><td><p>smoothness </p></td><td><p>float </p></td><td><p>Adjusts how smooth the material's surface appears, 0 being very rough and 1 being perfectly smooth. </p></td></tr><tr><td><p>reflectivity </p></td><td><p>float </p></td><td><p>A value from 0 to 1 representing the amount of light that is reflected. </p></td></tr><tr><td><p>metalness </p></td><td><p>float </p></td><td><p>A value from 0 to 1 representing how metallic the surface is. </p></td></tr><tr><td><p>ambient </p></td><td><p>float </p></td><td><p>How much to scale ambient lighting for this surface. </p></td></tr><tr><td><p>alpha </p></td><td><p>float </p></td><td><p>Adjusts the translucency of the surface. </p></td></tr><tr><td><p>IBL </p></td><td><p>float </p></td><td><p>Set to 0.0 or 1.0 to either disable/enable Image-Based Lighting for this surface fragment. </p></td></tr></tbody></table></div></dd></dl></p><p><h3 class="anchor" id="rBLlRBInd37d">vertex( )</h3></p><p>The vertex function allows the shader to manipulate vertices of models using this surface shader. It takes the following form:</p><p><div id="frag_GyFQPfDH7R1Y"><ul class="nav nav-pills"><li class="active"><a href="#GLSLGyFQPfDH7R1Y">GLSL</a></li></ul><div class="tab-content"><div id="GLSLGyFQPfDH7R1Y" class="tab-pane active"><pre><code class="glsl">void vertex(inout SurfaceInput i)
{
  // ...
}
</code></pre></div>
</div></div>
Notice that SurfaceInput is declared as "inout", so it acts as the sole input and sole output parameter for this function. Any values modified in this structure will propagate along to the surface( ) function as an input parameter.</p><p>Below is a quick example of modifying a model's vertices using this function:</p><p><div id="frag_KVYBVX9mRRiW"><ul class="nav nav-pills"><li class="active"><a href="#GLSLKVYBVX9mRRiW">GLSL</a></li></ul><div class="tab-content"><div id="GLSLKVYBVX9mRRiW" class="tab-pane active"><pre><code class="glsl">void vertex(inout SurfaceInput i)
{
  i.position = i.position + i.normal;
}
</code></pre></div>
</div></div>
That function will extrude all vertices by one unit along their normals.</p><p><h3 class="anchor" id="g5JFpjc2U5q4">Uniforms</h3></p><p>There are a number of shader uniforms accessible within the surface shaders which may prove useful.</p><p><dl><dd><div class="table-responsive"><table class="table table-striped table-bordered"><thead><tr><th><p>Name </p></th><th><p>Type </p></th><th><p>Description  </p></th></tr></thead><tbody><tr><td><p>uni_time </p></td><td><p>float </p></td><td><p>Indicates how much time has elapsed whilst the application has been active. Can be useful for animating surface properties. </p></td></tr><tr><td><p>uni_viewport </p></td><td><p>vec4 </p></td><td><p>Contains the current viewport parameters. (origin.x, origin.y, width, height) </p></td></tr><tr><td><p>uni_viewMat </p></td><td><p>mat4 </p></td><td><p>View matrix. Can be used to transform a position/direction into eye-space. </p></td></tr><tr><td><p>uni_viewMatInv </p></td><td><p>mat4 </p></td><td><p>Inverse view matrix. Can be used to transform from eye-space to world-space. </p></td></tr><tr><td><p>uni_proj </p></td><td><p>mat4 </p></td><td><p>Projection matrix. </p></td></tr><tr><td><p>uni_projInv </p></td><td><p>mat4 </p></td><td><p>Inverse projection matrix. </p></td></tr></tbody></table></div></dd></dl>
Extending the previous example to use one of these uniforms:</p><p><div id="frag_F1RPTXcYXemK"><ul class="nav nav-pills"><li class="active"><a href="#GLSLF1RPTXcYXemK">GLSL</a></li></ul><div class="tab-content"><div id="GLSLF1RPTXcYXemK" class="tab-pane active"><pre><code class="glsl">void vertex(inout SurfaceInput i)
{
  i.position = i.position + i.normal * sin(uni_time);
}
</code></pre></div>
</div></div>
That function will animate the deformation of the meshes vertices along the vertex normals, resulting in a model which will expand and collapse over time.</p><p><h3 class="anchor" id="TNOQS2qqDb8M">Input Parameters</h3></p><p>It is possible to also input custom properties to the surface shaders which can be modified from the user interface. For example, in our previous displacement example we may want to modify the magnitude from the user interface, this can be done as follows:</p><p><div id="frag_uc3QudAdDDk6"><ul class="nav nav-pills"><li class="active"><a href="#GLSLuc3QudAdDDk6">GLSL</a></li></ul><div class="tab-content"><div id="GLSLuc3QudAdDDk6" class="tab-pane active"><pre><code class="glsl">&lt;params&gt;
  &lt;MyMagnitude type=&quot;float&quot; value=&quot;1.0&quot; caption=&quot;Magnitude&quot; /&gt;
&lt;/params&gt;

uniform float MyMagnitude;

void vertex(inout SurfaceInput i)
{
  i.position = i.position + i.normal * sin(uni_time) * MyMagnitude;
}
</code></pre></div>
</div></div>
That code defines a user value "MyMagnitude" of type floating-point, with a default value of 1.0 and a caption of "Magnitude" which is how it will be shown in the UI. Notice how there must also be a uniform of the same type and name defined for the shader to access the value. To modify the magnitude the user can alter the "Magnitude" property which will now be visible when selecting the Surface Shader Instance.</p><p>These custom properties can also inherit their value from any material properties where the types match. This can be done by clicking on the button to the right of the input fields.</p><p><img src="surface_shader_param_inherit.png"></img></p><p>Following is some sample code showing usage of all the types available to the user parameters, along with an example of how they appear in the UI.</p><p><div id="frag_1H8w3ukSugxk"><ul class="nav nav-pills"><li class="active"><a href="#GLSL1H8w3ukSugxk">GLSL</a></li></ul><div class="tab-content"><div id="GLSL1H8w3ukSugxk" class="tab-pane active"><pre><code class="glsl">&lt;params&gt;
  &lt;MyFloat type=&quot;float&quot; /&gt;
  &lt;MyBool type=&quot;bool&quot; /&gt;  
  &lt;MyVec2 type=&quot;vec2&quot; /&gt;
  &lt;MyVec3 type=&quot;vec3&quot; /&gt;
  &lt;MyVec4 type=&quot;vec4&quot; /&gt;
  &lt;MyColour type=&quot;colour&quot; /&gt;
  &lt;MyTex2D type=&quot;texture2d&quot; /&gt;
  &lt;MyTex3D type=&quot;texture3d&quot; /&gt;
  &lt;MyTexCube type=&quot;texturecube&quot; /&gt;
&lt;/params&gt;

uniform float MyFloat;
uniform bool MyBool;
uniform vec2 MyVec2;
uniform vec3 MyVec3;
uniform vec4 MyVec4;
uniform vec3 MyColour;
uniform sampler2d MyTex2D;
uniform sampler3d MyTex3D;
uniform samplerCube MyTexCube;
</code></pre></div>
</div></div><img src="surface_shader_param_types.png"></img></p><hr/><div class="row footer-nav footer-links"><div class="col-sm-4"><p><span class="fas fa-arrow-circle-left" aria-hidden="true"></span>&nbsp;<a href="plugin_depends.html">Plugin Dependencies</a></p></div><div class="col-sm-4 col-sm-offset-4"><p class="pull-right"><a href="view_shader_intro.html">Writing View Shaders</a>&nbsp;<span class="fas fa-arrow-circle-right" aria-hidden="true"></span></p></div></div></div><div class="col-sm-2 col-sm-pull-10 "><div class="main-search"><form id="docs-search" autocomplete="off" class="form-horizontal" accept-charset="utf-8"><div class="input-group text-border"><input name="srch-term" id="srch-term" class="form-control" type="text" placeholder="Search"></div></form></div><div id="searchResults"><div class="list-group"><p class="list-group-item">No Results.</p></div></div><div class="list-group list-group-root"><span class="list-group-item"><a href="#side_getting_started" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="getting_started.html">Getting Started</a></span><div class="list-group collapse" id="side_getting_started"><span class="list-group-item"><a href="applua_intro.html">Using the Script Editor</a></span><span class="list-group-item"><a href="eventlua_intro.html">Using the Script Event System</a></span><span class="list-group-item"><a href="luaplugin_intro.html">Creating a Lua Plugin</a></span><span class="list-group-item"><a href="plugin_intro.html">Creating a Native Plugin</a></span><span class="list-group-item"><a href="plugin_wrangle_api.html">Accessing the API</a></span></div><span class="list-group-item"><a href="#side_architecture" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="architecture.html">Architecture</a></span><div class="list-group collapse" id="side_architecture"><span class="list-group-item"><a href="api_diagram.html">API Diagram</a></span><span class="list-group-item"><a href="metanodes.html">Metanodes</a></span><span class="list-group-item"><a href="properties.html">Properties</a></span><span class="list-group-item"><a href="nodes.html">Nodes</a></span><span class="list-group-item"><a href="observers.html">Observers</a></span><span class="list-group-item"><a href="scenegraph.html">Scene Graph</a></span><span class="list-group-item"><a href="plugin_directories.html">Plugin Search Paths</a></span></div><span class="list-group-item"><a href="best_practices.html">Best Practices</a></span><span class="list-group-item"><a href="#side_howto" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="howto.html">How To</a></span><div class="list-group collapse" id="side_howto"><span class="list-group-item"><a href="#side_howto_lua" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="howto_lua.html">Scripts</a></span><div class="list-group collapse" id="side_howto_lua"><span class="list-group-item"><a href="lua_assembly_howto.html">Work with Assembly Nodes</a></span><span class="list-group-item"><a href="lua_visual_howto.html">Work with Visual Nodes</a></span><span class="list-group-item"><a href="lua_light_howto.html">Work with Light Nodes</a></span><span class="list-group-item"><a href="lua_material_howto.html">Work with Material Nodes</a></span><span class="list-group-item"><a href="lua_lodgeo_howto.html">Work with Level of Detail and GeoGroup Nodes</a></span><span class="list-group-item"><a href="lua_sequence_howto.html">Work with Sequence Nodes</a></span><span class="list-group-item"><a href="lua_audio_howto.html">Work with Audio Nodes</a></span><span class="list-group-item"><a href="lua_video_howto.html">Work with Movie Nodes</a></span><span class="list-group-item"><a href="lua_metadata_howto.html">Work with Metadata and Attribute Nodes</a></span><span class="list-group-item"><a href="lua_settings_howto.html">Work with Settings Nodes</a></span><span class="list-group-item"><a href="lua_observers_howto.html">Work with Observers</a></span></div><span class="list-group-item"><a href="#side_howto_plugins" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="howto_plugins.html">Plugins</a></span><div class="list-group collapse" id="side_howto_plugins"><span class="list-group-item"><a href="importer_howto.html">Provide a Data Importer</a></span><span class="list-group-item"><a href="exporter_howto.html">Provide a Data Exporter</a></span><span class="list-group-item"><a href="context_menu_howto.html">Add a Context Menu</a></span><span class="list-group-item"><a href="ffi_howto.html">Use the Foreign Function Interface (FFI)</a></span><span class="list-group-item"><a href="luafunc_howto.html">Provide a Lua Function</a></span><span class="list-group-item"><a href="define_metanode_howto.html">Define a Custom MetaNode</a></span><span class="list-group-item"><a href="update_howto.html">Implement an Update Function</a></span><span class="list-group-item"><a href="observer_howto.html">Implement an Observer</a></span><span class="list-group-item"><a href="logging_howto.html">Write to the Application Log</a></span><span class="list-group-item"><a href="dialog_howto.html">Present a Modal Dialog</a></span><span class="list-group-item"><a href="progress_howto.html">Update the Loading Screen</a></span></div></div><span class="list-group-item show-path"><a href="#side_advanced" data-toggle="collapse"><i class="fas fa-minus-square list-toggle"></i></a><a href="advanced.html">Advanced Topics</a></span><div class="list-group collapse in" id="side_advanced"><span class="list-group-item"><a href="advanced_appcommands.html">Application Commands</a></span><span class="list-group-item"><a href="advanced_semantics.html">Semantics</a></span><span class="list-group-item"><a href="advanced_metanode_versioning.html">Metanode Versioning</a></span><span class="list-group-item"><a href="dynamic_loading.html">Enabling/Disabling Plugins at Runtime</a></span><span class="list-group-item"><a href="lua_coroutines.html">Coroutines in Lua Plugins</a></span><span class="list-group-item"><a href="lua_odbc.html">Using LuaSQL for ODBC Connections</a></span><span class="list-group-item"><a href="lua_com.html">Reference External Data Using the COM</a></span><span class="list-group-item"><a href="terminating_long_scripts.html">Terminating Long Scripts</a></span><span class="list-group-item"><a href="plugin_depends.html">Plugin Dependencies</a></span><span class="list-group-item show-path"><a href="surface_shader_intro.html">Writing Surface Shaders</a></span><span class="list-group-item"><a href="view_shader_intro.html">Writing View Shaders</a></span></div><span class="list-group-item"><a href="#side_changes" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="changes.html">Changelog</a></span><div class="list-group collapse" id="side_changes"><span class="list-group-item"><a href="v2023_2_to_v2024_1.html">New in 2024.1</a></span><span class="list-group-item"><a href="v2023_1_to_v2023_2.html">New in 2023.2</a></span><span class="list-group-item"><a href="v2021_2_to_v2021_3.html">New in 2021.3</a></span><span class="list-group-item"><a href="v2021_1_to_v2021_2.html">New in 2021.2</a></span><span class="list-group-item"><a href="v2020_2_to_v2021_1.html">New in 2021.1</a></span><span class="list-group-item"><a href="v2020_1_to_v2020_2.html">New in 2020.2</a></span><span class="list-group-item"><a href="v2019_3_to_v2020_1.html">New in 2020.1</a></span><span class="list-group-item"><a href="v2019_2_to_v2019_3.html">New in 2019.3</a></span><span class="list-group-item"><a href="v22_to_v2019_2.html">New in 2019.2</a></span><span class="list-group-item"><a href="v21_to_v22.html">New in 2.2.0</a></span><span class="list-group-item"><a href="v20_to_v21.html">New in 2.1.0</a></span><span class="list-group-item"><a href="#side_v13x_to_v2" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="v13x_to_v2.html">New in 2.0.0</a></span><div class="list-group collapse" id="side_v13x_to_v2"><span class="list-group-item"><a href="v13x_200_pivots.html">Pivot API Changes</a></span><span class="list-group-item"><a href="v13x_200_lua_co.html">Lua Event Coroutines</a></span><span class="list-group-item"><a href="v13x_200_lua_observers.html">Lua Observers</a></span></div></div><span class="list-group-item"><a href="namespacevrtree.html">vrtree</a></span><span class="list-group-item"><a href="namespacevrtree__cpp.html">vrtree_cpp</a></span><span class="list-group-item"><a href="namespacevt_core.html">vtCore</a></span><span class="list-group-item"><a href="group__api__core.html">Core</a></span><span class="list-group-item"><a href="group__api__ffi.html">Foreign Function Interface</a></span><span class="list-group-item"><a href="#side_group__api__metanodes" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="group__api__metanodes.html">Metanodes</a></span><div class="list-group collapse" id="side_group__api__metanodes"><span class="list-group-item"><a href="group__api__metanodes__general.html">General</a></span><span class="list-group-item"><a href="group__api__metanodes__properties.html">Properties</a></span><span class="list-group-item"><a href="group__api__metanodes__semantics.html">Semantics and Hints</a></span><span class="list-group-item"><a href="group__api__metadefs.html">Metanode Structure Definitions</a></span></div><span class="list-group-item"><a href="group__api__migrations.html">Migrations</a></span><span class="list-group-item"><a href="group__api__observer.html">Observers</a></span><span class="list-group-item"><a href="group__api__properties.html">Properties</a></span><span class="list-group-item"><a href="group__api__settings.html">Settings</a></span><span class="list-group-item"><a href="group__api__tree.html">Tree</a></span><span class="list-group-item"><a href="group__api__utils.html">Utilities</a></span><span class="list-group-item"><a href="#side_group__api__defs" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="group__api__defs.html">API Definitions</a></span><div class="list-group collapse" id="side_group__api__defs"><span class="list-group-item"><a href="group__api__types.html">Types</a></span><span class="list-group-item"><a href="group__api__proto.html">Function Prototypes</a></span><span class="list-group-item"><a href="group__api__flags.html">Flags</a></span><span class="list-group-item"><a href="group__api__io__flags.html">Save/Load Tree I/O Flags</a></span><span class="list-group-item"><a href="group__api__builder__flags.html">Build Filter flags</a></span><span class="list-group-item"><a href="group__api__loggingmask.html">Logging masks</a></span><span class="list-group-item"><a href="group__api__errors.html">Error codes</a></span></div><span class="list-group-item"><a href="group__api__exchange.html">VR Exchange</a></span><span class="list-group-item"><a href="#side_group__api__plugins" data-toggle="collapse"><i class="fas fa-plus-square list-toggle"></i></a><a href="group__api__plugins.html">Plugins</a></span><div class="list-group collapse" id="side_group__api__plugins"><span class="list-group-item"><a href="group__api__plugin__interface.html">Plugin Interface</a></span><span class="list-group-item"><a href="group__api__plugin__utils.html">Plugin Utilities</a></span></div><span class="list-group-item"><a href="group__api__lua.html">Lua API</a></span></div></div>
</div></div></body></html>